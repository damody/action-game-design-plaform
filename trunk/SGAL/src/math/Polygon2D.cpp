//
//
//  Generated by StarUML(tm) C++ Add-In
//
//  @ Project : Untitled
//  @ File Name : Polygon.cpp
//  @ Date : 2011/9/4
//  @ Author :
//
//

#include "Polygon2D.h"
#include "Quaternion.h"

using namespace boost::geometry;

void Polygon2D::BuildAABB()
{
}

void Polygon2D::BuildPolygon()
{
}

bool Polygon2D::IsCollision( const Polygon2D& rhs )
{
// 	if ( m_Polygon.outer().size() < 3 )
// 	{
// 		for ( int i = 0; i < m_Points.size(); i++ )
// 		{
// 			point2 pt( m_Points[0].x, m_Points[0].y );
//
// 			if ( within( pt, rhs.m_Polygon ) ) { return true; }
// 		}
// 	}
// 	else
// 	{
// 		return intersects<polygon, polygon>( m_Polygon, rhs.m_Polygon );
// 	}
	return false;
}


bool Polygon2D::CollisionZ( const Polygon2D& rhs )
{
	if ( abs( m_zPoint - rhs.m_zPoint ) <= ( m_zRange + rhs.m_zRange ) * 0.5 )
	{
		return true;
	}
	else
	{
		return false;
	}
}


void Polygon2D::ProjectPolygon( const Vec2& axis, const Polygon2D& polygon, float* min, float* max )
{
	// To project a point on an axis use the dot product
// 	float d = axis.dotProduct( polygon.m_Points[0] );
// 	*min = d;
// 	*max = d;
//
// 	for ( size_t i = 0; i < polygon.m_Points.size(); i++ )
// 	{
// 		d = polygon.m_Points[i].dotProduct( axis );
//
// 		if ( d < *min )
// 		{
// 			*min = d;
// 		}
// 		else
// 		{
// 			if ( d > *max )
// 			{
// 				*max = d;
// 			}
// 		}
// 	}
}

void Polygon2D::AddPoint( float x, float y )
{
	m_Polygon.outer().push_back( point2( x, y ) );
}

void Polygon2D::AddPoint( const Vec2& p )
{
	m_Polygon.outer().push_back( point2( p.x, p.y ) );
}

void Polygon2D::Offset( float x, float y )
{
	for ( auto it = m_Polygon.outer().begin();
	                it != m_Polygon.outer().end(); ++it )
	{
		it->x( it->x() + x );
		it->y( it->y() + y );
	}
}

void Polygon2D::Offset( const Vec2& v )
{
}


void Polygon2D::Offset( float x, float y, float z )
{
	for ( auto it = m_Polygon.outer().begin();
	                it != m_Polygon.outer().end(); ++it )
	{
		it->x( it->x() + x );
		it->y( it->y() + y );
	}
	m_zPoint += z;
}


void Polygon2D::Offset( const Vec3& v )
{
	m_zPoint += v.z;
}

void Polygon2D::SetAngle( float angle )
{
// 	for ( Vec2s::iterator it = m_Points.begin();
// 	                it != m_Points.end(); ++it )
// 	{
// 		*it = Quaternion::GetRotation( *it, angle - m_Angle, Vec2::ZERO );
// 	}
	m_Angle = angle;
}

void Polygon2D::Rotation( float angle, const Vec2& middle /*= Vec2::ZERO*/ )
{
	m_Angle = angle;
// 	for ( Vec2s::iterator it = m_Points.begin();
// 	                it != m_Points.end(); ++it )
// 	{
// 		*it = Quaternion::GetRotation( *it, angle, middle );
// 	}
}

void Polygon2D::Clear()
{
	m_Polygon.clear();
}

Polygon2D::~Polygon2D()
{
}


